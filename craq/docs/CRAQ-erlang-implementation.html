<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRAQ协议的Erlang实现源码分析</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .download-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: background-color 0.3s;
        }
        .download-btn:hover {
            background: #218838;
        }
        .chapter {
            background: white;
            margin: 20px 0;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .chapter h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .chapter h2 {
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        .chapter h3 {
            color: #7f8c8d;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .mermaid-container {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .info-box {
            background-color: #d1ecf1;
            padding: 15px;
            border-left: 4px solid #17a2b8;
            margin: 15px 0;
        }
        .warning-box {
            background-color: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .toc {
            background: #e9ecef;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 8px 0;
        }
        .toc a {
            text-decoration: none;
            color: #495057;
            font-weight: 500;
        }
        .toc a:hover {
            color: #007bff;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/html-docx-js/dist/html-docx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>CRAQ协议的Erlang实现源码分析</h1>
        <p>基于Chain Replication for Supporting High Throughput and Availability论文的深度技术分析</p>
        <button class="download-btn" onclick="convertMermaidToImages()">转换图表并导出Word</button>
    </div>

    <div class="toc">
        <h2>目录</h2>
        <ul>
            <li><a href="#chapter1">第一章：程序启动</a></li>
            <li><a href="#chapter2">第二章：消息的链式传递</a></li>
            <li><a href="#chapter3">第三章：消息的反向传递，直到commit</a></li>
            <li><a href="#chapter4">第四章：消息的持久化落地，以及落地的格式描述</a></li>
            <li><a href="#chapter5">第五章：CRAQ协议的优点和缺点</a></li>
        </ul>
    </div>

    <div class="chapter" id="chapter1">
        <h1>第一章：程序启动</h1>
        
        <h2>1.1 应用程序启动流程</h2>
        <p>CRAQ协议的Erlang实现采用OTP（Open Telecom Platform）架构，通过标准的Erlang应用程序启动机制来初始化整个分布式存储系统。</p>

        <div class="code-block">
start() ->
  lager:start(),
  application:start(erlang_craq).
        </div>

        <p>启动过程包含以下关键步骤：</p>
        <ol>
            <li><strong>日志系统初始化</strong>：通过lager启动日志记录系统</li>
            <li><strong>应用程序启动</strong>：启动erlang_craq应用程序</li>
            <li><strong>监督树构建</strong>：创建eh_system_sup和eh_data_server等关键进程</li>
        </ol>

        <h2>1.2 系统架构初始化</h2>
        
        <div class="mermaid-container">
            <div class="mermaid">
graph TD
    A[erlang_craq:start/0] --> B[lager:start/0]
    A --> C[application:start/1]
    C --> D[eh_app:start/2]
    D --> E[eh_system_sup:start_link/1]
    E --> F[eh_system_server:start_link/1]
    E --> G[eh_data_server:start_link/1]
    F --> H[gen_server初始化]
    G --> I[数据存储初始化]
    H --> J[系统状态设置为NOT_READY]
    I --> K[从磁盘读取历史数据]
            </div>
        </div>

        <h2>1.3 配置参数加载</h2>
        <p>系统启动时会加载关键配置参数，这些参数定义在eh_app_config记录中：</p>

        <div class="code-block">
-record(eh_app_config, {
    node_id,                    % 节点标识符
    node_order,                 % 节点排序方式(sorted/user_defined)
    failure_detector,           % 故障检测器
    repl_data_manager,          % 复制数据管理器
    storage_data,               % 存储数据处理器
    write_conflict_resolver,    % 写冲突解决器
    unique_id_generator,        % 唯一ID生成器
    query_handler,              % 查询处理器
    event_logger,               % 事件日志器
    data_checkpoint,            % 数据检查点间隔
    data_dir,                   % 数据目录
    file_repl_data_suffix,      % 复制数据文件后缀
    file_repl_data,             % 复制数据文件名
    file_repl_log,              % 复制日志文件
    debug_mode,                 % 调试模式
    sup_restart_intensity,      % 监督者重启强度
    sup_restart_period,         % 监督者重启周期
    sup_child_shutdown          % 子进程关闭超时
}).
        </div>

        <div class="info-box">
            <strong>关键点：</strong>node_id是每个节点的唯一标识符，在整个CRAQ链中用于确定节点的前驱和后继关系。
        </div>
    </div>

    <div class="chapter" id="chapter2">
        <h1>第二章：消息的链式传递</h1>

        <h2>2.1 复制环的建立</h2>
        <p>CRAQ协议的核心是建立一个有序的复制链。通过setup_repl/1函数来初始化复制环：</p>

        <div class="code-block">
setup_repl(NodeList) ->
  gen_server:abcast(NodeList, ?EH_SYSTEM_SERVER, {?EH_SETUP_REPL, NodeList}).
        </div>

        <p>每个节点接收到setup_repl消息后，会执行以下操作：</p>

        <div class="code-block">
handle_cast({?EH_SETUP_REPL, ReplRing}, #eh_system_state{app_config=AppConfig}=State) ->
  NodeId = eh_system_config:get_node_id(AppConfig),
  NodeOrder = eh_system_config:get_node_order(AppConfig),
  {ReplRing1, ReplRingOrder1, Pred, Succ} = 
    eh_repl_ring:get_ordered_list_pred_succ(NodeId, ReplRing, ReplRing, NodeOrder),
  % 设置前驱和后继节点
  NewState2 = NewState1#eh_system_state{
    repl_ring_order=ReplRingOrder1, 
    repl_ring=ReplRing1, 
    predecessor=Pred, 
    successor=Succ, 
    timestamp=Timestamp
  },
  {noreply, NewState2}.
        </div>

        <h2>2.2 前驱和后继节点的确定</h2>
        <p>eh_repl_ring模块负责管理复制环的拓扑结构，确定每个节点的前驱和后继关系：</p>

        <div class="mermaid-container">
            <div class="mermaid">
graph LR
    A[ec_n1@centos7-dev] --> B[ec_n2@centos7-dev]
    B --> C[ec_n3@centos7-dev]
    C --> A
    
    subgraph "节点关系"
        D[predecessor/4] --> E[确定前驱节点]
        F[successor/4] --> G[确定后继节点]
    end
            </div>
        </div>

        <div class="code-block">
predecessor(Node, NodeList, NodeOrderList, NodeOrder) ->
  {NewNodeList, _} = add(Node, NodeList, NodeOrderList, NodeOrder),
  {L1, L2} = lists:splitwith(fun(N) -> N =/= Node end, NewNodeList),
  case {length(L1), length(L2)} of
    {0, 0} -> undefined;
    {0, 1} -> undefined;
    {0, _} -> lists:last(L2);
    {_, _} -> lists:last(L1)
  end.

successor(Node, NodeList, NodeOrderList, NodeOrder) ->
  {NewNodeList, _} = add(Node, NodeList, NodeOrderList, NodeOrder),
  {L1, L2} = lists:splitwith(fun(N) -> N =/= Node end, NewNodeList),
  case {length(L1), length(L2)} of
    {0, 0} -> undefined;
    {0, 1} -> undefined;
    {_, 1} -> hd(L1);
    {_, _} -> [Node, Succ | _] = L2, Succ
  end.
        </div>

        <h2>2.3 更新消息的链式传递机制</h2>
        <p>当客户端发起更新请求时，消息会沿着复制链从头节点传递到尾节点：</p>

        <div class="highlight">
            <strong>关键流程：</strong>
            <ol>
                <li>客户端向任意节点发送更新请求</li>
                <li>接收节点判断自己在链中的位置</li>
                <li>如果不是头节点，将消息转发给头节点</li>
                <li>头节点开始链式传递，依次传递给后继节点</li>
                <li>每个节点接收消息后更新本地状态并传递给下一个节点</li>
            </ol>
        </div>

        <div class="code-block">
handle_cast({?EH_UPDATE, {From, Ref, ObjectList}}, State) ->
  NodeId = eh_system_config:get_node_id(AppConfig),
  case eh_node_state:client_state(State) of
    ?EH_READY ->
      % 处理更新消息
      UMsgList = eh_update_msg:get_msg(UpdateList, Timestamp1, From, NodeId, Ref),
      NewState1 = process_update_msg(UMsgList, State),
      % 传递给后继节点
      case State#eh_system_state.successor of
        undefined -> 
          % 这是尾节点，开始反向确认
          process_tail_commit(NewState1);
        SuccNode ->
          % 传递给后继节点
          gen_server:cast({?EH_SYSTEM_SERVER, SuccNode}, 
                         {?EH_SUCC_UPDATE, UMsgList}),
          NewState1
      end
  end.
        </div>

        <h2>2.4 消息传递的数据结构</h2>
        <p>更新消息使用特定的数据结构来携带必要信息：</p>

        <div class="code-block">
-record(eh_update_msg_key, {
    timestamp,      % 时间戳
    object_type,    % 对象类型
    object_id       % 对象ID
}).

-record(eh_update_msg_data, {
    update_data,    % 更新数据
    client_id,      % 客户端进程ID
    node_id,        % 节点ID
    msg_ref         % 消息引用
}).
        </div>

        <div class="info-box">
            <strong>设计要点：</strong>每个更新消息都包含时间戳，确保在分布式环境中能够正确排序和处理并发更新。
        </div>
    </div>

    <div class="chapter" id="chapter3">
        <h1>第三章：消息的反向传递，直到commit</h1>

        <h2>3.1 尾节点的Commit确认</h2>
        <p>在CRAQ协议中，当更新消息到达链的尾节点时，尾节点会发起commit确认过程。这个过程确保所有节点都已经接收并处理了更新消息。</p>

        <div class="mermaid-container">
            <div class="mermaid">
sequenceDiagram
    participant C as Client
    participant N1 as Head Node
    participant N2 as Middle Node  
    participant N3 as Tail Node
    
    C->>N1: Update Request
    N1->>N1: Process & Store
    N1->>N2: Forward Update
    N2->>N2: Process & Store
    N2->>N3: Forward Update
    N3->>N3: Process & Store
    N3->>N2: Commit Ack
    N2->>N1: Commit Ack
    N1->>C: Update Complete
            </div>
        </div>

        <h2>3.2 反向确认机制的实现</h2>
        <p>尾节点处理完更新后，会向前驱节点发送确认消息：</p>

        <div class="code-block">
% 尾节点处理逻辑
process_tail_update(UMsgList, State) ->
  % 1. 更新本地数据
  NewState1 = update_local_data(UMsgList, State),
  
  % 2. 发送反向确认给前驱节点
  case State#eh_system_state.predecessor of
    undefined ->
      % 这是单节点情况，直接回复客户端
      reply_to_client(UMsgList, NewState1);
    PredNode ->
      % 发送确认给前驱节点
      gen_server:cast({?EH_SYSTEM_SERVER, PredNode}, 
                     {?EH_PRED_PRE_UPDATE, UMsgList}),
      NewState1
  end.
        </div>

        <h2>3.3 中间节点的确认传递</h2>
        <p>中间节点接收到后继节点的确认后，会继续向前传递确认：</p>

        <div class="code-block">
handle_cast({?EH_PRED_PRE_UPDATE, UMsgList}, State) ->
  % 1. 标记消息为已确认
  NewState1 = mark_messages_committed(UMsgList, State),
  
  % 2. 检查是否为头节点
  case State#eh_system_state.predecessor of
    undefined ->
      % 头节点，回复客户端
      reply_to_clients(UMsgList, NewState1);
    PredNode ->
      % 继续向前传递确认
      gen_server:cast({?EH_SYSTEM_SERVER, PredNode}, 
                     {?EH_PRED_PRE_UPDATE, UMsgList}),
      NewState1
  end.
        </div>

        <h2>3.4 数据一致性保证</h2>
        <p>CRAQ协议通过以下机制保证数据一致性：</p>

        <div class="warning-box">
            <strong>一致性保证机制：</strong>
            <ul>
                <li><strong>顺序保证</strong>：所有更新按照时间戳顺序处理</li>
                <li><strong>原子性</strong>：要么所有节点都应用更新，要么都不应用</li>
                <li><strong>持久性</strong>：更新在commit前必须持久化到磁盘</li>
                <li><strong>可见性</strong>：只有commit的更新才对读操作可见</li>
            </ul>
        </div>

        <h2>3.5 Commit状态管理</h2>
        <p>系统使用状态机来管理每个更新消息的commit状态：</p>

        <div class="code-block">
% 消息状态定义
-define(EH_NOT_READY, eh_not_ready).      % 未就绪
-define(EH_READY, eh_ready).              % 已就绪
-define(EH_TRANSIENT, eh_transient).      % 临时状态
-define(EH_TRANSIENT_DU, eh_transient_data_updated).     % 数据已更新
-define(EH_TRANSIENT_TU, eh_transient_timestamp_updated). % 时间戳已更新

% 状态转换逻辑
update_message_state(UMsgKey, State) ->
  case maps:find(UMsgKey, State#eh_system_state.msg_data) of
    error ->
      % 新消息，设置为NOT_READY
      State#eh_system_state{
        msg_data = maps:put(UMsgKey, ?EH_NOT_READY, 
                           State#eh_system_state.msg_data)
      };
    {ok, ?EH_NOT_READY} ->
      % 收到确认，设置为READY
      State#eh_system_state{
        msg_data = maps:put(UMsgKey, ?EH_READY, 
                           State#eh_system_state.msg_data)
      }
  end.
        </div>

        <div class="highlight">
            <strong>关键实现细节：</strong>只有当消息状态变为READY时，相应的数据更新才会对客户端的读请求可见。这确保了读操作的一致性。
        </div>
    </div>

    <div class="chapter" id="chapter4">
        <h1>第四章：消息的持久化落地，以及落地的格式描述</h1>

        <h2>4.1 持久化存储架构</h2>
        <p>CRAQ的Erlang实现使用文件系统进行数据持久化，采用版本化文件管理和检查点机制来保证数据的可靠性和性能。</p>

        <div class="mermaid-container">
            <div class="mermaid">
graph TD
    A[更新请求] --> B[eh_data_server]
    B --> C[数据验证和处理]
    C --> D[内存数据更新]
    D --> E[持久化写入]
    E --> F[eh_storage_data_operation_api]
    F --> G[文件操作]
    G --> H[版本化文件]
    H --> I[数据检查点]
    
    subgraph "存储层次"
        J[内存Maps] --> K[临时队列]
        K --> L[磁盘文件]
    end
            </div>
        </div>

        <h2>4.2 数据持久化的关键代码位置</h2>
        <p>数据持久化的核心实现位于eh_data_server.erl的write_data函数中：</p>

        <div class="code-block">
% 文件：eh_data_server.erl，第85-95行
write_data(Timestamp, DIL0, D0, Q0, State) ->
  AppConfig = State#eh_data_state.app_config,
  File = State#eh_data_state.file,
  FileVersionNum = State#eh_data_state.file_version_num,
  DataUpdateCount = State#eh_data_state.data_update_count,
  
  % 关键持久化操作 - 第90行
  case eh_storage_data_operation_api:write(AppConfig, File, Q0, FileVersionNum, DataUpdateCount) of
    {ok, File1, FileVersionNum1, DataUpdateCount1} ->
      NewState = State#eh_data_state{
        timestamp=Timestamp, 
        data_index_list=DIL0, 
        data=D0, 
        transient_data=queue:new(), 
        data_update_count=DataUpdateCount1, 
        file_version_num=FileVersionNum1, 
        file=File1
      },
      {reply, ok, NewState};
    {error, File, FileVersionNum, DataUpdateCount1} ->
      {reply, ok, State#eh_data_state{data_update_count=DataUpdateCount1}}
  end.
        </div>

        <div class="info-box">
            <strong>关键代码位置：</strong>数据实际写入磁盘的操作发生在eh_storage_data_operation_api:write/5函数调用处（第90行）。
        </div>

        <h2>4.3 数据存储格式</h2>
        <p>CRAQ使用结构化的记录格式来存储数据，主要包括以下数据结构：</p>

        <div class="code-block">
% 存储键结构
-record(eh_storage_key, {
    object_type,    % 对象类型（原子）
    object_id       % 对象ID（任意项）
}).

% 存储值结构  
-record(eh_storage_value, {
    timestamp,      % 时间戳（非负整数）
    data_index,     % 数据索引（非负整数）
    status,         % 状态（活跃/非活跃）
    column,         % 列名（原子）
    value           % 值（任意项）
}).

% 完整存储数据结构
-record(eh_storage_data, {
    object_type,    % 对象类型
    object_id,      % 对象ID
    timestamp,      % 时间戳
    data_index,     % 数据索引
    status,         % 状态
    column,         % 列名
    value           % 值
}).
        </div>

        <h2>4.4 文件存储格式详解</h2>
        <p>数据在磁盘上的存储采用二进制格式，包含头部和数据部分：</p>

        <table>
            <tr>
                <th>字段</th>
                <th>大小</th>
                <th>描述</th>
            </tr>
            <tr>
                <td>Header Size</td>
                <td>固定字节</td>
                <td>头部大小信息</td>
            </tr>
            <tr>
                <td>Data Size</td>
                <td>变长</td>
                <td>数据部分大小</td>
            </tr>
            <tr>
                <td>Entry Data</td>
                <td>变长</td>
                <td>实际的存储记录数据</td>
            </tr>
        </table>

        <div class="code-block">
% 文件读写操作的核心逻辑
read(EntryOperation, File, Loc, {Timestamp, DataIndex}, M0) ->
  case eh_persist_storage_data:read_data(File, Loc, EntryOperation:header_byte_size()) of
    eof -> 
      {ok, Timestamp, DataIndex, M0};
    {error, _} -> 
      {error, Timestamp, DataIndex, M0};
    {ok, Loc1, HData} ->
      DataSize = EntryOperation:entry_header(HData),
      case eh_persist_storage_data:read_data(File, Loc1, DataSize) of
        {ok, Loc2, RData} ->
          case EntryOperation:binary_to_entry(HData, RData) of
            {ok, Entry} ->
              % 递归读取下一条记录
              read(EntryOperation, File, Loc2, 
                   eh_data_util:update_timestamp(Entry, {Timestamp, DataIndex}), 
                   eh_data_util:add_key_value(Entry, M0))
          end
      end
  end.
        </div>

        <h2>4.5 版本化文件管理</h2>
        <p>系统采用版本化文件管理策略，当数据更新达到检查点阈值时，会创建新的版本文件：</p>

        <div class="highlight">
            <strong>版本化策略：</strong>
            <ul>
                <li>文件命名格式：{NodeId}_repl_{Version}.data</li>
                <li>检查点触发：当更新次数达到data_checkpoint配置值</li>
                <li>旧版本保留：用于故障恢复和数据一致性检查</li>
                <li>自动清理：定期清理过期的版本文件</li>
            </ul>
        </div>

        <div class="code-block">
% 版本文件创建逻辑
case DataUpdateCount >= DataCheckPoint of
  true ->
    case read(AppConfig, File) of
      {ok, _, _, _} ->
        close(File),
        FileVersionNum1 = FileVersionNum + 1,
        VersionedFileName = eh_file_name:get_full_versioned_file_name(FileVersionNum1, AppConfig),
        {ok, File1} = open(VersionedFileName),
        {ok, File1, FileVersionNum1, 0};
      {error, _, _, _} ->
        {error, File, FileVersionNum, DataUpdateCount + 1}
    end;
  false ->
    {ok, File, FileVersionNum, DataUpdateCount + 1}
end.
        </div>

        <h2>4.6 数据恢复机制</h2>
        <p>系统启动时会从磁盘读取所有版本文件来恢复数据状态：</p>

        <div class="code-block">
% 数据恢复过程 - eh_data_server:init/1
init([AppConfig]) ->
  DataDir = eh_system_config:get_data_dir(AppConfig),
  FileName = eh_system_config:get_file_repl_data(AppConfig),
  
  % 读取所有版本文件恢复数据
  {_, Timestamp, DataIndexList, D0} = 
    eh_storage_data_operation_api:read_all(AppConfig, 
      eh_file_name:get_full_versioned_file_names(DataDir, FileName)),
  
  % 创建新的版本文件用于后续写入
  FileVersionNum = eh_file_name:get_version_num(DataDir, FileName) + 1,
  VersionedFileName = eh_file_name:get_full_versioned_file_name(FileVersionNum, AppConfig),
  {ok, File} = eh_storage_data_operation_api:open(VersionedFileName),
  
  State = #eh_data_state{
    timestamp=Timestamp, 
    data_index_list=DataIndexList, 
    data=D0, 
    file_version_num=FileVersionNum, 
    file=File, 
    app_config=AppConfig
  },
  {ok, State}.
        </div>

        <div class="warning-box">
            <strong>注意：</strong>数据恢复过程中，系统会按照时间戳顺序重放所有历史更新，确保数据状态的一致性。
        </div>
    </div>

    <div class="chapter" id="chapter5">
        <h1>第五章：CRAQ协议的优点和缺点</h1>

        <h2>5.1 CRAQ协议的优点</h2>

        <h3>5.1.1 高读取性能</h3>
        <p>CRAQ协议的最大优势是显著提升了读取性能，特别适合读多写少的工作负载：</p>
        
        <div class="info-box">
            <strong>读取性能优势：</strong>
            <ul>
                <li><strong>分布式读取</strong>：客户端可以从链中的任意节点读取数据，而不仅仅是头节点</li>
                <li><strong>负载均衡</strong>：读请求可以分散到多个节点，避免单点瓶颈</li>
                <li><strong>就近访问</strong>：客户端可以选择网络距离最近的节点进行读取</li>
                <li><strong>并发读取</strong>：多个读请求可以并行处理，不会相互阻塞</li>
            </ul>
        </div>

        <h3>5.1.2 强一致性保证</h3>
        <p>CRAQ协议在提供高性能的同时，仍然保证强一致性：</p>

        <div class="code-block">
% 一致性读取的实现逻辑
handle_call({?EH_QUERY, {ObjectType, ObjectId}}, _From, State) ->
  % 1. 检查本地是否有未提交的更新
  case check_pending_updates(ObjectType, ObjectId, State) of
    {true, PendingData} ->
      % 有未提交更新，需要查询尾节点获取最新状态
      query_tail_node(ObjectType, ObjectId, State);
    false ->
      % 没有未提交更新，可以直接返回本地数据
      Reply = eh_data_util:query_data(ObjectType, ObjectId, State#eh_data_state.data),
      {reply, {ObjectType, ObjectId, Reply}, State}
  end.
        </div>

        <h3>5.1.3 容错能力</h3>
        <p>CRAQ协议具有良好的容错能力：</p>
        <ul>
            <li><strong>节点故障检测</strong>：通过failure_detector及时发现节点故障</li>
            <li><strong>链重构</strong>：故障节点被移除后，自动重构复制链</li>
            <li><strong>数据恢复</strong>：故障节点恢复后可以从其他节点同步数据</li>
        </ul>

        <h2>5.2 CRAQ协议的缺点</h2>

        <h3>5.2.1 写入性能限制</h3>
        <p>CRAQ协议的写入性能存在一些限制：</p>

        <div class="warning-box">
            <strong>写入性能瓶颈：</strong>
            <ul>
                <li><strong>顺序写入</strong>：所有写入必须按顺序通过整个链，增加了延迟</li>
                <li><strong>链长度影响</strong>：链越长，写入延迟越高</li>
                <li><strong>尾节点瓶颈</strong>：尾节点需要处理所有的commit确认</li>
                <li><strong>网络开销</strong>：每次写入需要多次网络通信</li>
            </ul>
        </div>

        <h3>5.2.2 复杂性增加</h3>
        <p>相比简单的主从复制，CRAQ协议增加了系统复杂性：</p>

        <div class="mermaid-container">
            <div class="mermaid">
graph TD
    A[复杂性来源] --> B[状态管理]
    A --> C[消息协调]
    A --> D[故障处理]
    A --> E[一致性维护]
    
    B --> B1[节点状态]
    B --> B2[消息状态]
    B --> B3[数据版本]
    
    C --> C1[链式传递]
    C --> C2[反向确认]
    C --> C3[并发控制]
    
    D --> D1[节点故障]
    D --> D2[网络分区]
    D --> D3[数据恢复]
    
    E --> E1[读写一致性]
    E --> E2[时间戳管理]
    E --> E3[冲突解决]
            </div>
        </div>

        <h3>5.2.3 特定场景限制</h3>
        <p>CRAQ协议在某些场景下可能不是最优选择：</p>

        <table>
            <tr>
                <th>场景</th>
                <th>限制</th>
                <th>原因</th>
            </tr>
            <tr>
                <td>写密集型应用</td>
                <td>性能不佳</td>
                <td>链式写入延迟高</td>
            </tr>
            <tr>
                <td>大规模集群</td>
                <td>扩展性受限</td>
                <td>链长度影响性能</td>
            </tr>
            <tr>
                <td>低延迟要求</td>
                <td>难以满足</td>
                <td>多跳网络通信</td>
            </tr>
            <tr>
                <td>频繁拓扑变化</td>
                <td>开销较大</td>
                <td>链重构成本高</td>
            </tr>
        </table>

        <h2>5.3 适用场景分析</h2>

        <h3>5.3.1 最佳适用场景</h3>
        <div class="highlight">
            <strong>CRAQ协议最适合以下场景：</strong>
            <ul>
                <li><strong>读多写少</strong>：读写比例在10:1或更高</li>
                <li><strong>中等规模</strong>：3-7个节点的集群</li>
                <li><strong>强一致性需求</strong>：需要严格的数据一致性保证</li>
                <li><strong>地理分布</strong>：节点分布在不同地理位置，需要就近读取</li>
            </ul>
        </div>

        <h3>5.3.2 与其他协议的比较</h3>
        <div class="code-block">
协议比较：
┌─────────────┬──────────┬──────────┬──────────┬──────────┐
│    协议     │ 读性能   │ 写性能   │ 一致性   │ 复杂度   │
├─────────────┼──────────┼──────────┼──────────┼──────────┤
│ CRAQ        │   高     │   中     │   强     │   中     │
│ Chain Repl  │   低     │   中     │   强     │   低     │
│ Raft        │   中     │   中     │   强     │   高     │
│ Paxos       │   中     │   低     │   强     │   高     │
│ 主从复制    │   高     │   高     │   弱     │   低     │
└─────────────┴──────────┴──────────┴──────────┴──────────┘
        </div>

        <h2>5.4 性能优化建议</h2>

        <h3>5.4.1 Erlang实现的优化点</h3>
        <p>基于源码分析，以下是一些性能优化建议：</p>

        <div class="info-box">
            <strong>优化策略：</strong>
            <ul>
                <li><strong>批量处理</strong>：将多个小更新合并为批量操作</li>
                <li><strong>异步I/O</strong>：使用异步文件操作减少阻塞</li>
                <li><strong>内存缓存</strong>：增加内存缓存减少磁盘访问</li>
                <li><strong>网络优化</strong>：使用更高效的序列化格式</li>
                <li><strong>并发控制</strong>：优化锁粒度和并发度</li>
            </ul>
        </div>

        <h3>5.4.2 配置调优</h3>
        <div class="code-block">
% 关键配置参数调优
-record(eh_app_config, {
    data_checkpoint = 1000,        % 增加检查点间隔减少文件操作
    sup_restart_intensity = 100,   % 适当的重启强度
    sup_restart_period = 1,        % 重启周期
    sup_child_shutdown = 2000      % 子进程关闭超时
}).

% 性能监控指标
- 消息处理延迟
- 磁盘I/O吞吐量  
- 网络带宽使用率
- 内存使用情况
- GC频率和耗时
        </div>

        <div class="warning-box">
            <strong>部署建议：</strong>在生产环境中部署CRAQ系统时，需要根据具体的工作负载特征和性能要求，仔细调优各项配置参数，并建立完善的监控体系。
        </div>
    </div>

    <script>
        // 初始化Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true
            }
        });

        // Mermaid图表转换为图片
        async function convertMermaidToImages() {
            const loadingMsg = document.createElement('div');
            loadingMsg.style.position = 'fixed';
            loadingMsg.style.top = '50%';
            loadingMsg.style.left = '50%';
            loadingMsg.style.transform = 'translate(-50%, -50%)';
            loadingMsg.style.background = 'rgba(0,0,0,0.8)';
            loadingMsg.style.color = 'white';
            loadingMsg.style.padding = '20px';
            loadingMsg.style.borderRadius = '5px';
            loadingMsg.style.zIndex = '1000';
            loadingMsg.textContent = '正在将Mermaid图表转换为图片...';
            document.body.appendChild(loadingMsg);

            try {
                const mermaidContainers = document.querySelectorAll('.mermaid-container');
                let allConverted = true;

                for (const container of mermaidContainers) {
                    const mermaidElement = container.querySelector('.mermaid');
                    if (mermaidElement) {
                        // 等待Mermaid渲染完成
                        await new Promise(resolve => setTimeout(resolve, 100));

                        try {
                            // 使用html2canvas将Mermaid图表转换为图片
                            const canvas = await html2canvas(mermaidElement, {
                                backgroundColor: '#f8f9fa',
                                scale: 2 // 提高分辨率
                            });

                            const imgData = canvas.toDataURL('image/png');

                            // 创建图片元素替换Mermaid图表
                            const imgElement = document.createElement('img');
                            imgElement.src = imgData;
                            imgElement.style.width = '100%';
                            imgElement.style.maxWidth = '800px';
                            imgElement.style.height = 'auto';
                            imgElement.style.border = '1px solid #ddd';
                            imgElement.style.borderRadius = '5px';
                            imgElement.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';

                            // 替换Mermaid图表为图片
                            container.replaceChild(imgElement, mermaidElement);
                        } catch (error) {
                            console.error('图表转换失败:', error);
                            allConverted = false;
                            // 转换失败时显示错误信息
                            const errorDiv = document.createElement('div');
                            errorDiv.innerHTML = `
                                <div style="text-align:center; padding:20px; background:#ffe6e6; border:1px solid #ff9999; border-radius:5px;">
                                    <p style="color:#d32f2f; margin:0;">图表转换失败，请直接在浏览器中查看图表效果</p>
                                </div>
                            `;
                            container.replaceChild(errorDiv, mermaidElement);
                        }
                    }
                }

                // 移除加载提示
                document.body.removeChild(loadingMsg);

                if (allConverted) {
                    // 所有图表转换成功，开始导出Word
                    setTimeout(exportToWord, 500);
                } else {
                    alert('部分图表转换失败，请检查浏览器控制台获取详细信息。');
                }
            } catch (error) {
                console.error('转换过程出错:', error);
                document.body.removeChild(loadingMsg);
                alert('图表转换过程中出现错误: ' + error.message);
            }
        }

        // 导出Word文档（使用图片版本）
        async function exportToWord() {
            const loadingMsg = document.createElement('div');
            loadingMsg.style.position = 'fixed';
            loadingMsg.style.top = '50%';
            loadingMsg.style.left = '50%';
            loadingMsg.style.transform = 'translate(-50%, -50%)';
            loadingMsg.style.background = 'rgba(0,0,0,0.8)';
            loadingMsg.style.color = 'white';
            loadingMsg.style.padding = '20px';
            loadingMsg.style.borderRadius = '5px';
            loadingMsg.style.zIndex = '1000';
            loadingMsg.textContent = '正在导出包含图片的Word文档...';
            document.body.appendChild(loadingMsg);

            try {
                // 直接使用当前包含图片的文档内容
                const content = document.documentElement.outerHTML;
                const converted = htmlDocx.asBlob(content);
                saveAs(converted, 'CRAQ协议Erlang实现分析-包含图表图片.docx');

                // 移除加载提示
                document.body.removeChild(loadingMsg);

                // 显示成功提示
                alert('Word文档导出成功！图表已转换为图片格式。');
            } catch (error) {
                console.error('导出失败:', error);
                document.body.removeChild(loadingMsg);
                alert('导出过程中出现错误: ' + error.message);
            }
        }
    </script>
</body>
</html>